### 实验三（1）
#### fork()的利用
* fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。
* 用fork()函数来产生新的子进程。
* fork() ，pthread_creat(), vfork()的系统调用分别是sys_fork()，sys_clone(), sys_vfork()，它们的底层都用的是do_fork（），只是传的参数，和标志不同
* ![avatar](https://img-blog.csdn.net/20180114230728134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTHl0MTU4Mjk3OTc3NTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
* do_fork（）：1、定义PCB指针struct task_struct *p; 2、分配PID，cat /proc/sys/kernel/pid_max命令可以查看一个系统支持的最大进程数，进程数的范围0~32768，理论值。 3、调用copy_process方法，创建子进程的task_struct.

#### execl()函数
* <b>定义函数</b>：int execl(const char * path, const char * arg, ...);  
<b>函数说明</b>：execl()用来执行参数path 字符串所代表的文件路径, 接下来的参数代表执行该文件时传递过去的argv(0), argv[1], ..., 最后一个参数必须用空指针(NULL)作结束.  
<b>返回值</b>：如果执行成功则函数不会返回, 执行失败则直接返回-1, 失败原因存于errno 中.  
### 实验三（2）
#### pipe()函数
* int pipe(int filedes[2])：创建一个管道，成功返回0，失败返回0，并在error中存入错误码。fd[0]:读管道，fd[1]:写管道。
* 必须在fork()中调用pipe()，否则子进程不会继承文件描述符。
* 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道； 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。
#### sem_open()函数
* 函数说明：创建并初始化<b>有名信号量</b>。  
头文件：#include <semaphore.h>  
函数原型：sem_t *sem_open(const char *name,int oflag,mode_t mode,unsigned int value);  
参数：  
name 信号灯的外部名字  
oflag 选择创建或打开一个现有的信号灯  
mode 权限位  
value 信号灯初始值  
返回值：成功时返回指向信号灯的指针，出错时为SEM_FAILED  
* 基于内存的信号量不使用任何类似于O_CREAT标志的东西，也就是说，sem_init总是初始化信号量的值，因此，对于一个给定的信号量，我们必须小心保证只调用sem_init一次，对于一个已经初始化过的信号量调用sem_init,结果是未定义的。
* 有名信号量是随内核持续的，所以如果如果我们不调用sem_unlink来删除它，它将一直存在，直到内核重启。
那有名信号量保存在哪里呢？
实时上，跟消息队列类似，它保存在 /dev/shm 这个目录中。你可以在这个目录中找到你创建了的，但是没有调用sem_unlink的信号量。
由此可见有名信号量的实现是以共享内存区实现的。

#### sem_unlink()函数
* 删除有名信号量

#### sem_wait()函数
*  sem_wait函数也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait(),线程将会继续执行，介信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会地等待直到有其它线程增加了这个值使它不再是0为止。如果有两个线程都在sem_wait()中等待同一个信号量变成非零值，那么当它被第三个线程增加一个“1”时，等待线程中只有一个能够对信号量做减法并继续执行，另一个还将处于等待状态。
#### sem_post()函数
* sem_post函数的作用是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的；而同时对同一个文件进行读、加和写操作的两个程序就有可能会引起冲突。信号量的值永远会正确地加一个“2”－－因为有两个线程试图改变它。
#### write()函数
* 函数定义：ssize_t write (int fd, const void * buf, size_t count);   
函数说明：write()会把参数buf所指的内存写入count个字节到参数fd所指的文件内。  
返回值：如果顺利write()会返回实际写入的字节数（len）。当有错误发生时则返回-1，错误代码存入errno中。  
* write()函数从buf写数据到fd中时，若buf中数据无法一次性读完，那么第二次读buf中数据时，其读位置指针（也就是第二个参数buf）不会自动移动，需要程序员来控制，而不是简单的将buf首地址填入第二参数即可。如可按如下格式实现读位置移动：write(fp, p1+len, (strlen(p1)-len)。 这样write第二次循环时便会从p1+len处写数据到fp, 之后的也一样。由此类推，直至(strlen(p1)-len变为0
#### read()函数
* 函数定义：ssize_t read(int fd, void * buf, size_t count);  
函数说明：read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。  
返回值：返回值为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据。若参数count 为0, 则read()不会有作用并返回0。  
注意：read时fd中的数据如果小于要读取的数据，就会引起阻塞。  
#### 信号量
* mutux为抢占资源，即往管道里面写东西是抢占式的，所以我们要wait,post一下，保护写入。
* 有名用于进程，无名用于线程。
#### waitpid()函数
* waitpid()会暂时停止目前进程的执行，直到有信号来到或子进程结束。
* 函数说明编辑  
如果在调用 waitpid()时子进程已经结束,则 waitpid()会立即
返回子进程结束状态值。 子进程的结束状态值会由参数 status 返回,
而子进程的进程识别码也会一起返回。如果不在意结束状态值,则
参数 status 可以设成 NULL。参数 pid 为欲等待的子进程识别码,
其他数值意义如下:  
pid<-1 等待进程组识别码为 pid 绝对值的任何子进程。  
pid=-1 等待任何子进程,相当于 wait()。  
pid=0 等待进程组识别码与目前进程相同的任何子进程。  
pid>0 等待任何子进程识别码为 pid 的子进程。  
#### pipe-max
* 就是一个不断调用write（）函数往管道里面写内容，知道write报错返回-1，结束读写。
* 每次写入1kb内容，这是我们自己定的。
#### memset()
* memset是计算机中C/C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。
* 函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。  
memset：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法
### 实验三（3）
* 类似读者写者问题，多个写者，一个读者。
* 运用了消息队列
* 先定义了四个信号量，分别用于写，读，确定线程1已经结束写，确定线程2已结结束写。
* 定义了一个结构体msg_date，里面存有数据类型，数据内容，和数据走向（确定是sender1写向receive还是sender2）。
* 定义了一个全局变量id。
* 定义了两个int类型的值，send_1_over,send_2_over用于确定两个线程是否完成写操作。
#### strcmp（）函数
* C/C++函数，比较两个字符串
设这两个字符串为str1，str2，
若str1==str2，则返回零；  
若str1<str2，则返回负数；  
若str1>str2，则返回正数。  
#### strcpy（）函数
* strcpy是一种C语言的标准库函数，strcpy把含有'\0'结束符的字符串复制到另一个地址空间，返回值的类型为char*。
#### msgsnd (将消息写入到消息队列)
* 函数说明  
将msgp消息写入到标识符为msqid的消息队列  
函数原型  
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)  
函数传入值  
msqid  
消息队列标识符  
msgp  
发送给队列的消息。msgp可以是任何类型的结构体，但第一个字段必须为long类型，即表明此发送消息的类型，msgrcv根据此接收消息。msgp定义的参照格式如下：  
    struct s_msg{ /*msgp定义的参照格式*/  
     long type; /* 必须大于0,消息类型 */  
     char mtext[256]; /*消息正文，可以是其他任何类型*/  
    } msgp;  
msgsz  
要发送消息的大小，不含消息类型占用的4个字节,即mtext的长度  
msgflg  
0：当消息队列满时，msgsnd将会阻塞，直到消息能写进消息队列  
IPC_NOWAIT：当消息队列已满的时候，msgsnd函数不等待立即返回  
IPC_NOERROR：若发送的消息大于size字节，则把该消息截断，截断部分将被丢弃，且不通知发送进程。  
* msgsnd()为阻塞函数，当消息队列容量满或消息个数满会阻塞。消息队列已被删除，则返回EIDRM错误；被信号中断返回E_INTR错误。  
#### msgrcv()函数
* 	从标识符为msqid的消息队列读取消息并存于msgp中，读取后把此消息从消息队列中删除
* 	msgtyp
0：接收第一个消息；>0：接收类型等于msgtyp的第一个消息；<0：接收类型等于或者小于msgtyp绝对值的第一个消息
#### pthread_exit（）函数
* 退出线程，约等于return
#### sem_init（）函数
* int sem_init(sem_t *sem,int pshared,unsigned int value); 
* sem_init函数是Posix信号量操作中的函数。sem_init() 初始化一个定位在 sem 的匿名信号量。value 参数指定信号量的初始值。 pshared 参数指明信号量是由进程内线程共享，还是由进程之间共享。如果 pshared 的值为 0，那么信号量将被进程内的线程共享，并且应该放置在这个进程的所有线程都可见的地址上(如全局变量，或者堆上动态分配的变量)。
* 第一个参数:信号量名   
看一个例子，比如有两个线程都要往打印机上打东西，但是同一时刻只能打一个。   
那么首先用sem_init初始化一个信号量，注意pshared表示允许几个进程共享该信号量，一般设0用于进程内的多线程共享，要看是否支持进程共享，请查看下你的系统的man手册。   
第三个参数value表示可用的资源的数目，即信号灯的数目，咱们这儿只有1个打印机所以设成1。   
然后线程调用sem_wait取获取这个信号灯，第一个线程一看，有1个，他就拿到了，然后可以继续后继操作，此时信号灯自动减1，变成0个。那么第二个线程调用sem_wait时就会阻塞在这儿了。   
第一个线程完成打印后，调用sem_post释放信号灯，信号灯数目变成1，将会唤醒等待的第二个线程，然后第二个线程接着打印。   
最后当所有任务完成后，主线程调用sem_destroy释放这个信号量。  
#### int msgget(key_t key, int msgflag）函数
* 用于创建一个新的或打开一个已经存在的消息队列，此消息队列与key相对应。参数： key：函数ftok的返回值或IPC_PRIVATE。 msgflag： IPC_CREAT:创建新的消息队列。 IPC_EXCL:与IPC_CREAT一同使用，表示如果要创建的消息队列已经存在，则返回错误。 IPC_NOWAIT:读写消息队列要求无法满足时，不阻塞。返回值： 调用成功返回队列标识符,否则返回-1.
#### pthread_creat()函数
* 它的功能是创建线程（实际上就是确定调用该线程函数的入口点），在线程创建以后，就开始运行相关的线程函数。
* 第一个参数为指向线程标识符的指针。  
第二个参数用来设置线程属性。  
第三个参数是线程运行函数的起始地址。  
最后一个参数是运行函数的参数。  
* 若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。  
#### pthread_join（）函数
* pthread_join()函数会一直阻塞调用线程，直到指定的线程终止。当pthread_join()返回之后，应用程序可回收与已终止线程关联的任何数据存储空间。 
* 用于等待其他线程结束：当调用 pthread_join() 时，当前线程会处于阻塞状态，直到被调用的线程结束后，当前线程才会重新开始执行。
*  加入pthread_join后，主线程"main"会一直等待直到tid这个线程执行完毕自己才结束
### 实验三（4）
* common.h定义了一些两个程序必要的函数，结构体
#### shmget()函数
* int shmget(key_t key, size_t size, int shmflg);
* 创建共享内存
* 第一个参数，与信号量的semget函数一样，程序需要提供一个参数key（非0整数），它有效地为共享内存段命名，shmget()函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回-1.  
不相关的进程可以通过该函数的返回值访问同一共享内存，它代表程序可能要使用的某个资源，程序对所有共享内存的访问都是间接的，程序先通过调用shmget()函数并提供一个键，再由系统生成一个相应的共享内存标识符（shmget()函数的返回值），只有shmget()函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。  
第二个参数，size以字节为单位指定需要共享的内存容量  
第三个参数，shmflg是权限标志，它的作用与open函数的mode参数一样，如果要想在key标识的共享内存不存在时，创建它的话，可以与IPC_CREAT做或操作。共享内存的权限标志与文件的读写权限一样，举例来说，0644,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。  
#### shmat()函数
* 第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。
* void *shmat(int shm_id, const void *shm_addr, int shmflg);  
* 第一个参数，shm_id是由shmget()函数返回的共享内存标识。  
第二个参数，shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。  
第三个参数，shm_flg是一组标志位，通常为0。  
调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.  
#### 判断sem
* 用sem_getvalue获取信号量的值，然后在while循环前进行赋值操作使其永远为1，其目的是防止之前的操作出现ctrl+c强行结束进程，而信号量值没有清空。
* 这段代码的目的是防止之前使用Ctrl+C强行终止进程导致重新允许时初始化信号量时，信号量sem_send的值为之前运行的0
#### sem_close（）函数
* 关闭一个信号量并没有将他从系统中删除。POSIX 有名信号量是随内核持续的：即使当前没有进程打开着某个信号量，他的值仍保持。
#### strcat()函数
* d和s所指内存区域不可以重叠且d必须有足够的空间来容纳s的字符串。
返回指向d的指针
#### shmctl()函数
* 删除共享内存  
* int shmctl(int shmid, int cmd, struct shmid_ds *buf)  
* 函数传入值  
shmid  
共享内存标识符  
cmd  
IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中  
IPC_SET：改变共享内存的状态，把buf所指的shmid_ds结构中的uid、gid、mode复制到共享内存的shmid_ds结构内  
IPC_RMID：删除这片共享内存  
buf  
共享内存管理结构体。具体说明参见共享内存内核结构定义部分  
* 不用shmdt是因为shmdt只是分离共享内存。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。  
